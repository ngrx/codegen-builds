{"version":3,"sources":["../../../modules/codegen/src/metadata/get-optional-properties.ts","../../../modules/codegen/src/metadata/get-properties.ts","../../../modules/codegen/src/metadata/get-required-properties.ts","../../../modules/codegen/src/metadata/get-type.ts","../../../modules/codegen/src/metadata/is-action-descendent.ts","../../../modules/codegen/src/metadata/is-exported.ts","../../../modules/codegen/src/action-interface.ts","../../../modules/codegen/src/printers/action-factory-declaration.ts","../../../modules/codegen/src/printers/enum-declaration.ts","../../../modules/codegen/src/printers/import-declaration.ts","../../../modules/codegen/src/printers/type-dictionary-declaration.ts","../../../modules/codegen/src/printers/type-union-declaration.ts","../../../modules/codegen/src/collect-metadata.ts","../../../modules/codegen/src/find-files.ts","../../../modules/codegen/src/codegen.ts"],"names":["getOptionalProperties","props","filter","prop","questionToken","map","name","getText","required","getProperties","node","members","ts.isPropertySignature","getRequiredProperties","_a","getType","action","typeProperty","find","property","ts.isLiteralTypeNode","undefined","isActionDescendent","statement","heritageClauses","some","clause","types","type","expression","hasExportModifier","ts.getCombinedModifierFlags","ts.ModifierFlags","Export","isTopLevel","parent","kind","ts.SyntaxKind","SourceFile","isExported","parseActionType","result","actionTypeRegex","exec","Error","category","printActionFactoryDeclaration","ts.createFunctionDeclaration","ts.createToken","ExportKeyword","getActionFactoryName","properties","ts.createParameter","QuestionToken","ts.createTypeReferenceNode","getActionName","ts.createBlock","ts.createReturn","ts.createObjectLiteral","ts.createPropertyAssignment","ts.createPropertyAccess","ts.createIdentifier","getActionEnumName","getActionEnumPropName","concat","ts.createShorthandPropertyAssignment","printEnumDeclaration","actions","firstInterface","ts.createEnumDeclaration","value","getActionType","ts.createEnumMember","ts.createLiteral","printImportDeclaration","filename","ts.createImportDeclaration","ts.createImportClause","ts.createNamedImports","ts.createImportSpecifier","printTypeDictionaryDeclaration","firstAction","ts.createTypeAliasDeclaration","getActionLookupName","ts.createTypeLiteralNode","ts.createPropertySignature","JSON","stringify","printTypeUnionDeclaration","getActionUnionName","ts.createUnionTypeNode","collectMetadata","fileName","sourceFile","interfaces","statements","ts.isInterfaceDeclaration","collector.isExported","collector.isActionDescendent","m","collector.getType","enterface","actionType","_.trim","literal","getFullText","collector.getRequiredProperties","collector.getProperties","collector.getOptionalProperties","length","printers.printImportDeclaration","printers.printEnumDeclaration","printers.printTypeUnionDeclaration","printers.printTypeDictionaryDeclaration","printers.printActionFactoryDeclaration","printActionFactory","ast","resultFile","ts.createSourceFile","ts.ScriptTarget","ES2015","ts.ScriptKind","TS","printer","ts.createPrinter","newLine","ts.NewLineKind","LineFeed","printNode","ts.EmitHint","Unspecified","join","findFiles","globPattern","Promise","resolve","reject","glob","cwd","process","ignore","error","files","readFile$1","file","fs.readFile","data","writeFile$1","contents","fs.writeFile","encoding","createSourceFile$1","codegen","filesIndicator","ora","start","sent","succeed","_i","files_1","indicator","parsedPath","path.parse","readFile","createSourceFile","output","target","path.resolve","dir","writeFile","fail","message","RegExp","getActionCategory","_.flow","v","getActionCategoryToken","_.camelCase","_.upperFirst","_.snakeCase","toUpperCase","require"],"mappings":"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","file":"./dist/codegen/bundles/codegen.umd.min.js","sourcesContent":["import * as ts from 'typescript';\nimport { ActionInterfaceProperty } from '../action-interface';\n/**\n * @param {?} props\n * @return {?}\n */\nexport function getOptionalProperties(\n  props: ts.PropertySignature[]\n): ActionInterfaceProperty[] {\n  return props.filter(prop => prop.questionToken).map(prop => ({\n    name: prop.name.getText(),\n    required: false,\n  }));\n}\n","import * as ts from 'typescript';\n/**\n * @param {?} node\n * @return {?}\n */\nexport function getProperties(\n  node: ts.InterfaceDeclaration\n): ts.PropertySignature[] {\n  return node.members.filter(ts.isPropertySignature);\n}\n","import * as ts from 'typescript';\nimport { ActionInterfaceProperty } from '../action-interface';\n/**\n * @param {?} props\n * @return {?}\n */\nexport function getRequiredProperties(\n  props: ts.PropertySignature[]\n): ActionInterfaceProperty[] {\n  return props\n    .filter(prop => !prop.questionToken)\n    .map(prop => ({\n      name: prop.name.getText(),\n      required: true,\n    }))\n    .filter(({ name }) => name !== 'type');\n}\n","import * as ts from 'typescript';\nimport { getProperties } from './get-properties';\n/**\n * @param {?} action\n * @return {?}\n */\nexport function getType(\n  action: ts.InterfaceDeclaration\n): ts.LiteralTypeNode | undefined {\n  const /** @type {?} */ typeProperty = getProperties(action).find(\n    property => property.name.getText() === 'type'\n  );\n\n  if (!typeProperty) {\n    return undefined;\n  }\n\n  return ts.isLiteralTypeNode( /** @type {?} */((typeProperty.type as any)))\n    ? /** @type {?} */(( typeProperty.type as any))\n    : undefined;\n\n  // return !!typeProperty && ts.isLiteralTypeNode(typeProperty.type) ? typeProperty.type : undefined;\n}\n","import * as ts from 'typescript';\n/**\n * @param {?} statement\n * @return {?}\n */\nexport function isActionDescendent(\n  statement: ts.InterfaceDeclaration\n): boolean {\n  const /** @type {?} */ heritageClauses = statement.heritageClauses;\n\n  if (heritageClauses) {\n    return heritageClauses.some(clause => {\n      /**\n       * TODO: This breaks if the interface looks like this:\n       * \n       *   interface MyAction extends ngrx.Action { }\n       * \n       */\n      return clause.types.some(type => type.expression.getText() === 'Action');\n    });\n  }\n\n  return false;\n}\n","import * as ts from 'typescript';\n/**\n * @param {?} node\n * @return {?}\n */\nfunction hasExportModifier(node: ts.Node): boolean {\n  return (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0;\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction isTopLevel(node: ts.Node): boolean {\n  return !!node.parent && node.parent.kind === ts.SyntaxKind.SourceFile;\n}\n/**\n * @param {?} node\n * @return {?}\n */\nexport function isExported(node: ts.Node): boolean {\n  return hasExportModifier(node) && isTopLevel(node);\n}\n","import * as _ from 'lodash';\n\nexport interface ActionInterfaceProperty {\n  name: string;\n  required: boolean;\n}\n\nexport interface ActionInterface {\n  name: string;\n  actionType: string;\n  properties: ActionInterfaceProperty[];\n}\n\nconst /** @type {?} */ actionTypeRegex = new RegExp(/\\[(.*?)\\](.*)/);\n/**\n * @param {?} type\n * @return {?}\n */\nfunction parseActionType(type: string) {\n  const /** @type {?} */ result = actionTypeRegex.exec(type);\n\n  if (result === null) {\n    throw new Error(`Could not parse action type \"${type}\"`);\n  }\n\n  return {\n    category: /** @type {?} */(( result[1] as string)),\n    name: /** @type {?} */(( result[2] as string)),\n  };\n}\n\nexport const /** @type {?} */ getActionType = (enterface: ActionInterface) =>\n  enterface.actionType;\nexport const /** @type {?} */ getActionName = (enterface: ActionInterface) => enterface.name;\nexport const /** @type {?} */ getActionCategory = _.flow(\n  getActionType,\n  parseActionType,\n  v => v.category\n);\nexport const /** @type {?} */ getActionCategoryToken = _.flow(\n  getActionCategory,\n  _.camelCase,\n  _.upperFirst\n);\nexport const /** @type {?} */ getActionEnumName = _.flow(\n  getActionCategoryToken,\n  v => `${v}ActionType`\n);\nexport const /** @type {?} */ getActionEnumPropName = _.flow(getActionName, _.snakeCase, v =>\n  v.toUpperCase()\n);\nexport const /** @type {?} */ getActionUnionName = _.flow(\n  getActionCategoryToken,\n  v => `${v}Actions`\n);\nexport const /** @type {?} */ getActionLookupName = _.flow(\n  getActionCategoryToken,\n  v => `${v}ActionLookup`\n);\nexport const /** @type {?} */ getActionFactoryName = _.flow(\n  getActionName,\n  _.camelCase,\n  _.upperFirst,\n  v => `create${v}`\n);\n","import * as ts from 'typescript';\nimport {\n  ActionInterface,\n  getActionFactoryName,\n  getActionName,\n  getActionEnumName,\n  getActionEnumPropName,\n} from '../action-interface';\n/**\n * @param {?} action\n * @return {?}\n */\nexport function printActionFactoryDeclaration(action: ActionInterface) {\n  return ts.createFunctionDeclaration(\n    undefined,\n    [ts.createToken(ts.SyntaxKind.ExportKeyword)],\n    undefined,\n    getActionFactoryName(action),\n    undefined,\n    action.properties.map(({ name, required }) => {\n      return ts.createParameter(\n        undefined,\n        undefined,\n        undefined,\n        name,\n        required ? undefined : ts.createToken(ts.SyntaxKind.QuestionToken),\n        ts.createTypeReferenceNode(\n          `${getActionName(action)}[\"${name}\"]`,\n          undefined\n        ),\n        undefined\n      );\n    }),\n    ts.createTypeReferenceNode(getActionName(action), undefined),\n    ts.createBlock(\n      [\n        ts.createReturn(\n          ts.createObjectLiteral([\n            ts.createPropertyAssignment(\n              'type',\n              ts.createPropertyAccess(\n                ts.createIdentifier(getActionEnumName(action)),\n                ts.createIdentifier(getActionEnumPropName(action))\n              )\n            ),\n            ...action.properties.map(({ name }) => {\n              return ts.createShorthandPropertyAssignment(name, undefined);\n            }),\n          ])\n        ),\n      ],\n      true\n    )\n  );\n}\n","import * as ts from 'typescript';\nimport {\n  ActionInterface,\n  getActionEnumName,\n  getActionEnumPropName,\n  getActionType,\n} from '../action-interface';\n/**\n * @param {?} actions\n * @return {?}\n */\nexport function printEnumDeclaration(actions: ActionInterface[]) {\n  const [firstInterface] = actions;\n\n  return ts.createEnumDeclaration(\n    undefined,\n    [ts.createToken(ts.SyntaxKind.ExportKeyword)],\n    getActionEnumName(firstInterface),\n    actions\n      .map(action => ({\n        prop: getActionEnumPropName(action),\n        value: getActionType(action),\n      }))\n      .map(({ prop, value }) => {\n        return ts.createEnumMember(prop, ts.createLiteral(value));\n      })\n  );\n}\n","import * as ts from 'typescript';\nimport { ActionInterface, getActionName } from '../action-interface';\n/**\n * @param {?} filename\n * @param {?} actions\n * @return {?}\n */\nexport function printImportDeclaration(\n  filename: string,\n  actions: ActionInterface[]\n) {\n  return ts.createImportDeclaration(\n    undefined,\n    undefined,\n    ts.createImportClause(\n      undefined,\n      ts.createNamedImports(\n        actions\n          .map(getActionName)\n          .map(name =>\n            ts.createImportSpecifier(undefined, ts.createIdentifier(name))\n          )\n      )\n    ),\n    ts.createIdentifier(`'./${filename}'`)\n  );\n}\n","import * as ts from 'typescript';\nimport {\n  ActionInterface,\n  getActionLookupName,\n  getActionType,\n  getActionName,\n} from '../action-interface';\n/**\n * @param {?} actions\n * @return {?}\n */\nexport function printTypeDictionaryDeclaration(actions: ActionInterface[]) {\n  const [firstAction] = actions;\n\n  return ts.createTypeAliasDeclaration(\n    undefined,\n    [ts.createToken(ts.SyntaxKind.ExportKeyword)],\n    getActionLookupName(firstAction),\n    undefined,\n    ts.createTypeLiteralNode(\n      actions.map(action => {\n        return ts.createPropertySignature(\n          undefined,\n          JSON.stringify(getActionType(action)),\n          undefined,\n          ts.createTypeReferenceNode(getActionName(action), undefined),\n          undefined\n        );\n      })\n    )\n  );\n}\n","import * as ts from 'typescript';\nimport {\n  ActionInterface,\n  getActionName,\n  getActionUnionName,\n} from '../action-interface';\n/**\n * @param {?} actions\n * @return {?}\n */\nexport function printTypeUnionDeclaration(actions: ActionInterface[]) {\n  const [firstAction] = actions;\n\n  return ts.createTypeAliasDeclaration(\n    undefined,\n    [ts.createToken(ts.SyntaxKind.ExportKeyword)],\n    getActionUnionName(firstAction),\n    undefined,\n    ts.createUnionTypeNode(\n      actions\n        .map(getActionName)\n        .map(name => ts.createTypeReferenceNode(name, undefined))\n    )\n  );\n}\n","import * as ts from 'typescript';\nimport * as _ from 'lodash';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as collector from './metadata/index';\nimport * as printers from './printers/index';\nimport { ActionInterface } from './action-interface';\n\nexport interface ActionMetadata {\n  name: string;\n  type: string;\n  properties: { name: string; optional: boolean }[];\n}\n/**\n * @param {?} fileName\n * @param {?} sourceFile\n * @return {?}\n */\nexport function collectMetadata(\n  fileName: string,\n  sourceFile: ts.SourceFile\n): ts.Node[] | undefined {\n  const /** @type {?} */ interfaces = sourceFile.statements\n    .filter(ts.isInterfaceDeclaration)\n    .filter(collector.isExported)\n    .filter(collector.isActionDescendent)\n    .filter(m => !!collector.getType(m))\n    .map((enterface): ActionInterface => ({\n      name: enterface.name.getText(),\n      actionType: _.trim( /** @type {?} */((\n        collector.getType(enterface))).literal.getFullText(),\n        ' \\'\"`'\n      ),\n      properties: [\n        ...collector.getRequiredProperties(collector.getProperties(enterface)),\n        ...collector.getOptionalProperties(collector.getProperties(enterface)),\n      ],\n    }));\n\n  if (interfaces.length === 0) {\n    undefined;\n  }\n\n  return [\n    printers.printImportDeclaration(fileName, interfaces),\n    printers.printEnumDeclaration(interfaces),\n    printers.printTypeUnionDeclaration(interfaces),\n    printers.printTypeDictionaryDeclaration(interfaces),\n    ...interfaces.map(action => printers.printActionFactoryDeclaration(action)),\n  ];\n}\n/**\n * @param {?} ast\n * @return {?}\n */\nexport function printActionFactory(ast: ts.Node[]) {\n  const /** @type {?} */ resultFile = ts.createSourceFile(\n    '',\n    '',\n    ts.ScriptTarget.ES2015,\n    false,\n    ts.ScriptKind.TS\n  );\n\n  const /** @type {?} */ printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\n  return ast\n    .map(statement =>\n      printer.printNode(ts.EmitHint.Unspecified, statement, resultFile)\n    )\n    .join('\\n\\n');\n}\n","import * as path from 'path';\nconst /** @type {?} */ glob = require('glob');\n/**\n * @param {?} globPattern\n * @return {?}\n */\nexport function findFiles(globPattern: string): Promise<string[]> {\n  return new Promise((resolve, reject) => {\n    glob(\n      globPattern,\n      { cwd: process.cwd(), ignore: ['**/node_modules/**'] },\n      (error: any, files: string[]) => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve(files);\n      }\n    );\n  });\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as ts from 'typescript';\nimport { collectMetadata, printActionFactory } from './collect-metadata';\nimport { findFiles } from './find-files';\nconst /** @type {?} */ ora = require('ora');\n/**\n * @param {?} file\n * @return {?}\n */\nasync function readFile(file: string): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    fs.readFile(file, 'utf8', (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n/**\n * @param {?} file\n * @param {?} contents\n * @return {?}\n */\nasync function writeFile(file: string, contents: string): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(file, contents, { encoding: 'utf8' }, error => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n/**\n * @param {?} data\n * @return {?}\n */\nfunction createSourceFile(data: string) {\n  return ts.createSourceFile('', data, ts.ScriptTarget.ES2015, true);\n}\n/**\n * @param {?} glob\n * @return {?}\n */\nexport async function codegen(glob: string) {\n  const /** @type {?} */ filesIndicator = ora(`Searching for files matching \"${glob}\"`).start();\n  const /** @type {?} */ files = await findFiles(glob);\n  filesIndicator.succeed(`Found ${files.length} files for pattern \"${glob}\"`);\n\n  for (let /** @type {?} */ file of files) {\n    const /** @type {?} */ indicator = ora(file).start();\n\n    try {\n      const /** @type {?} */ parsedPath = path.parse(file);\n      const /** @type {?} */ contents = await readFile(file);\n      const /** @type {?} */ sourceFile = createSourceFile(contents);\n      const /** @type {?} */ ast = collectMetadata(parsedPath.name, sourceFile);\n\n      if (!ast) {\n        throw new Error(`No actions found for file \"${file}\"`);\n      }\n\n      const /** @type {?} */ output = printActionFactory(ast);\n      const /** @type {?} */ target = path.resolve(\n        parsedPath.dir,\n        `./${parsedPath.name}.helpers.ts`\n      );\n      await writeFile(target, output);\n\n      indicator.succeed(`Found ${ast.length} actions in ${file}`);\n    } catch ( /** @type {?} */e) {\n      indicator.fail(( /** @type {?} */((e as Error))).message);\n    }\n  }\n}\n"]}